# Алгоритм: загрузка файла → вложение → LLM → JSON → коллекция

Описан целевой поток: пользователь загружает файл, он прикрепляется как вложение, затем по зашитому промпту отправляется в LLM для извлечения информации, результат сохраняется в JSON, коллекция в итоге содержит и исходные файлы, и сгенерированные JSON.

---

## 1. Общая схема

```
[Пользователь] → Выбор файла / перетаскивание
        ↓
[Фронтенд] → Файл как вложение к слоту (Бизнес-план, Стратегия, Свои цели и т.д.)
        ↓
[Создание коллекции] → POST /api/collections → создаётся коллекция
        ↓
[Загрузка файлов] → POST /api/documents/upload (для каждого прикреплённого файла)
        ↓
[Бэкенд] → Сохранение файла на диск + запись в индекс (document_type, collection_id, preprocessed=false)
        ↓
[Предобработка] → POST /api/documents/{id}/preprocess (вручную по кнопке или автоматически после загрузки)
        ↓
[Бэкенд] → Извлечение текста из файла → промпт по типу документа → запрос к LLM
        ↓
[LLM] → Возвращает один JSON-объект по заданной схеме
        ↓
[Бэкенд] → Сохранение JSON в индекс документа (parsed_json) + флаг preprocessed=true
        ↓
[Коллекция] → Содержит исходные файлы (на диске) + в метаданных каждого документа — parsed_json (извлечённая структура)
```

Итог: у каждой коллекции есть документы; у каждого документа — исходный файл (вложение) и, после предобработки, извлечённый JSON (важная информация в структурированном виде).

---

## 2. Пошаговый алгоритм

### Шаг 1. Файл как вложение (фронтенд)

- Пользователь в форме «Новая коллекция» прикрепляет файлы к слотам (Бизнес-план, Стратегия, Регламент, Положение о департаменте, Свои цели).
- Файл хранится в состоянии компонента (например, `files[slotId] = File`).
- Вложение не отправляется на сервер до нажатия «Создать».

**Важно:** один слот = один тип документа (`document_type`) и не более одного файла на слот в текущей реализации.

---

### Шаг 2. Создание коллекции

1. Пользователь нажимает «Создать».
2. Фронтенд вызывает `POST /api/collections` с названием (и при необходимости описанием).
3. Бэкенд создаёт коллекцию (id, name, даты), сохраняет в `uploads/collections.json` (или аналог).
4. В ответ возвращается объект коллекции с `id`. Этот `id` далее используется как `collection_id` для всех документов этой коллекции.

---

### Шаг 3. Загрузка файлов (вложения попадают на сервер)

Для каждого слота, где выбран файл:

1. Фронтенд вызывает `POST /api/documents/upload` с телом `multipart/form-data` (файл), query-параметрами:
   - `document_type` — тип слота (например `chairman_goals`, `business_plan_checklist`);
   - `collection_id` — id только что созданной коллекции.
2. Бэкенд:
   - генерирует `document_id` (например UUID);
   - сохраняет файл на диск по пути вида `uploads/{document_type}/{document_id}_{filename}`;
   - добавляет запись в индекс документов (`uploads/index.json` или аналог): `id`, `relative_path`, `document_type`, `collection_id`, `preprocessed: false`, без `parsed_json`.
3. В ответ возвращаются метаданные документа (id, имя файла, тип, `preprocessed: false`).

Итог: коллекция создана, у неё есть документы — каждый документ это «вложение» (исходный файл на диске + запись в индексе). Поля коллекции при этом не содержат самих файлов; файлы хранятся как документы с привязкой к `collection_id`.

---

### Шаг 4. Зашитый промпт и вызов LLM (предобработка)

Предобработка выполняется для уже загруженного документа (по кнопке «Предобработать» или, в перспективе, автоматически после загрузки).

1. Фронтенд вызывает `POST /api/documents/{document_id}/preprocess` (без тела).
2. Бэкенд:
   - по `document_id` находит документ в индексе и его `document_type`;
   - читает файл с диска по `relative_path`;
   - извлекает текст из файла (PDF, DOCX, TXT, XLSX и т.д.) в один строковый текст;
   - формирует промпт:
     - **системный промпт** — общий (например: «вернуть только валидный JSON, без markdown»);
     - **пользовательский промпт** — **зашитый** для данного `document_type` из конфига (например `preprocess_prompts.py`): описание желаемой JSON-схемы и инструкция «по тексту документа сформируй JSON…»;
   - отправляет в LLM (OpenAI-совместимый API: Open Web UI и т.п.) запрос: system + user (извлечённый текст);
   - парсит ответ модели как JSON; при ошибке парсинга возвращает ошибку и не меняет документ.
3. LLM возвращает один JSON-объект (структура зависит от типа: цели руководителя, чеклисты и т.д.).

**Важно:** промпт не вводится пользователем при загрузке — он жёстко задан в коде/конфиге по `document_type`, чтобы схема извлечения была предсказуемой и безопасной.

---

### Шаг 5. Сохранение результата в JSON и обновление документа

1. Бэкенд проверяет, что ответ LLM — валидный JSON и при необходимости что он соответствует ожидаемой структуре (минимальная валидация).
2. Сохраняет этот JSON в запись документа в индексе:
   - `parsed_json` = полученный объект;
   - `preprocessed` = true.
3. Индекс сохраняется на диск (тот же `index.json` или аналог). Отдельный физический «JSON-файл» на диске для каждого документа не обязателен — достаточно поля в индексе; при необходимости можно дополнительно сохранять копию в `uploads/{type}/{document_id}_parsed.json`.
4. В ответ на `POST .../preprocess` бэкенд возвращает `preprocessed: true` и при необходимости фрагмент `parsed_json` для отображения на фронте.

Итог: документ в коллекции теперь имеет и исходное вложение (файл), и извлечённую структуру (JSON). Коллекция «содержит JSON» в смысле: у её документов заполнено поле `parsed_json`.

---

### Шаг 6. Коллекция «с JSON-файлами»

- **Коллекция** — сущность с id и названием; хранит только метаданные.
- **Документы коллекции** — записи в общем индексе с `collection_id = id` этой коллекции.
- У каждого документа:
  - есть исходный файл (вложение) на диске;
  - после успешной предобработки есть `parsed_json` (извлечённая важная информация в JSON).
- Для чата/поиска можно использовать либо исходные файлы, либо сохранённые JSON (или оба), в зависимости от реализации RAG/поиска.

Таким образом, «коллекция с JSON-файлами» = коллекция, у документов которой заполнены `parsed_json` (и при необходимости сохранены отдельные _parsed.json файлы на диске).

---

## 3. Где что реализовано (текущее состояние)

| Шаг | Где | Комментарий |
|-----|-----|-------------|
| Вложение в форме | Фронтенд: `ImportPage`, состояние `files` | Файл привязан к слоту до «Создать». |
| Создание коллекции | API `POST /api/collections` | Коллекция создаётся, возвращается `id`. |
| Загрузка файлов | API `POST /api/documents/upload` | Файл пишется на диск, в индекс добавляется документ с `collection_id`, `preprocessed=false`. |
| Зашитый промпт | Бэкенд: `preprocess_prompts.py` | По `document_type` выбирается системный + пользовательский промпт (схема JSON). |
| Вызов LLM | Бэкенд: `services/llm.py` → `preprocess_document_to_json` | Текст документа + промпт → запрос к OpenAI-совместимому API. |
| Сохранение JSON | Бэкенд: `document_store.set_parsed_json` | В записи документа в индексе: `parsed_json`, `preprocessed=true`. |
| Предобработка по кнопке | Фронтенд: кнопка «Предобработать» → `POST /documents/{id}/preprocess` | Запускается после загрузки, вручную. |

---

## 4. Варианты доработки

- **Автозапуск предобработки:** после успешной загрузки каждого документа вызывать `POST /documents/{id}/preprocess` без участия пользователя (с учётом лимитов LLM и очереди).
- **Отдельные JSON-файлы:** при успешном ответе LLM дополнительно записывать `uploads/{type}/{document_id}_parsed.json` для бэкапов и отладки.
- **Повторная предобработка:** разрешить вызывать preprocess повторно (перезапись `parsed_json`) при смене промпта или модели.
- **Валидация JSON по схеме:** проверять `parsed_json` по JSON Schema для данного `document_type` перед сохранением.

Этот алгоритм можно использовать как основу для реализации и проверки потока «вложение → промпт → LLM → JSON → коллекция».
